Professor: Michael Wilder
website: `http://www2.cs.uidaho.edu/~mdwilder/cs210/`
Office Hours: MWF 1:30-2:20 JEB 220

Mon, Aug 22
  * Imperitive Langues
    - Ex: C
    - Hallmarks
      * Assignment
      * Iteration
      * Order of execution is critical
  * Functional Langues
    - Ex: ML, Lisp
    - Hallmarks
      * Single-values variables
      * Heavy use of recursion
  * Logic
    - Ex: Prolog
    - Hallmarks
      * Program expressed as rules in formal logic
  * Object Oriented
    - Ex: C++, Java
    - Hallmarks
      * Usually an extension of imperitive programming
      * Constructs to help programmers use 'objects'

Wed, Aug 24
  Strengths and Weaknesses
    Different language groups show to advantage on different kinds of problems
    Decide for yourself at the end of the semster, after experimenting with them
    For now, one comment: don't jump to conclusions based on factorial!

Fri, Aug 26
  About those families
    There are many other language family terms (not exhaustive and sometimes overlapping)
      - Applicative, concurrent, constraint, declarative, definitional, procedural, scripting, single-assignment
    Some *multi-paradigm languages straddle families: JavaScript, OCaml, Python, Ruby
    Others are so unique that assigning them to a family is pointless

  Forth Factorial (Language that cannot be classified into a category)
  ```
  : FACTORIAL
    1 SAP BEGIN ?DUP WHILE TUCK * SWAP 1- REPEAT ;
  ```
    Stack oriented language
    Postscript is similar
    Could be called imperative, but has little in common with most imperative languages


Mon, Aug 29
  Fighting the Language
    - Languages always favor a particular style, but do not force the programmer to follow it
    - It is always possible to write in a style not favored by the language
    - It is not usually a good idea
  Programming Experience Influenced Language Design
    - Corrections to design problems make future dialects, as already noted
    - Programming styles can emerge before there is a language that supports them
      * Programming with objects predated object-oriented languages
      * Automated theorem proving predates logic languages
  Other connections: Computer Architecture
    - Language evolutino drives and is driven by hardware evolution
      * Call stack support - languages with recursion
      * Parallel architectures - parallel languages
      * Internet - Java
  Turing Equivalence
    - Languages have different strengths, but fundamentally they all have the same power
    - All have the same power as various mathematical models of computation
    - Church-turing thesis: This is what 'computability' means

  Defining Program Syntax
    - Syntax: How programs look, their form and structure
      * Syntax is defined using a kind of formal grammar
    - Semantics: What programs do, their behavior and meaning
      * Axiomatic: using axioms to derive meaning of a program
      * Operational: Specifying how the VM interprets your programs
      * Denotational: Mathematical formalism
  Grammar
    - English Grammar:
      <S> ::= <NP><V><NP>
      <NP> ::= <A><N>
      * The grammar is a set of rules that say how to build a tree - A parse tree
      * You put <S> at the root of the tree
      * The grammar's rules say how children can be added at any point in the tree
      * for insttance, the rule <s> ::= <NP> <V> <NP> says you can add nodes <NP>, <V>, and <NP> in that order, as children of <S>
    - Programming language Grammar
      <exp> ::= <exp> + <exp> | <exp> * <exp> | ( <exp> | a | b | c )
      * An expression can be the sum of two expressions, or the product of two expressions, or a parenthesized subexpression
      * Or it can be one of the variables a, b, or c

Wed, Aug 31
  A BNF grammar consists of four parts
    - A set of tokens
    - The set of non-terminal symbolsence of one or more things, each of which a non-terminal or a token
    - The start symbol
    - The set of productions

    The Productions are the tree building rules
    Each one has a left side, the separator ::= and a right side
    - The right hand side can be a sequ


Mon, Sep 12
  Operator Terminology
    - Infix: a + b
    - Prefix: + a b
    - Postfix: a b +
    Unary Operators: Can be either Prefix or Postfix
  <exp> ::= <exp> + <exp> | <exp> * <exp> | (<exp>) | a | b | c

  Operator Precedence
    Applies when the order of evaluation is not completely decided by parentheses
    Each operator has a precedence leve, and thos with higher precedence are performed before those with lower precedence, as if parenthesized
    Most languages put * before + such that `a+b*c = a+(b*c)`

Fri, Sep 16
  Language Systems
    * The Classical Sequence
      - IDEs are wonderful, but...
      - Old-fashioned, un-integrated systems make the steps involved in running a program more clear
      - We will look the classical sequence of steps involved in running a program

      Integrated Development Environment
      Toolchain:
        A series of tools that have inputs/outputs changed together
        Various tools can (theoretically) be swapped out
        Hard to change in IDEs

    Creating
      - The programmer uses an editor to create a text file containing the program
      - A high-level language: Machine independent

    Compiling
      - Compiler translates to assembly language
      - Machine-specific
      - Each line represents either a piece of data, or a single machine-level instruction
      - Programs used to be written directly in assembly language, before Fortran
      - Now used directly only when the compiler does not do what you want, which is rare

    Assembling
      - Assembly language is still not directly executable
        * Text format, readable by people
        * Still has names, not memory addresses
        * Assembler converts each assembly-language instruction into the machine's binary format: its machine language
        * Resulting object file not readable by people

    Linking
      - Object file still not directly executable
        * Missing some parts
        * Still has some names
        * Mostly machine language, but not entirely
      - Linker collects and combines all the different parts
      - Result is the executable file

Fri, Sep 23
  Virtual Machines
    Cross-platform execution
      - vm can be implemented in software on many different platforms 
      - simulating physical machines is harder
    Heightened security
      - Running program is never directly in charge
      - Interpreter can intervene if the program tries to do something it shouldn't
  The Java Virtual Machine
    Java languages systems usually compile to code for a VM, the JVM
    JVM language is sometimes called bytecode
    Bytecode interpeter is part of almost every webbrowser
    When you browse a ge that contains a Java applet, the browser runs the applet by interpreting its bytecode
  Types of intepreters
    Pure interpreter
      Intermediate language = high-level language
    Tokenizing interpreter
      Intermediate language = token stream
    Intermediate-code compiler
      Intermediate language = virtual machine language
    Native-code compiler
      Intermediate language = physical machine language

    Delayed Linking
      Delay linking step
      Code for library functions is not included in the executable file of the calling program
      Windows:
        - Libraries of functions for delayed linking are stored in .dll files: dynamic-link library
        - Many language systems share this format
        Two flavors:
          - Load-time dynamic linking
            * Loader finds .dll files and links the program to functions it needs, just before running
          - Run-time dynamic linking
            * Running program makes explicit system calls to find .dll files and load specific functions
      Unix:
        - Libraries of functions for delayed linnking are stored in .so files: shared object
        - Suffix .so followed by version number
        - Many language systems share this format
        - Two flavors
          - shared libraries: 
            * Loader linnks the program to functions it needs before running
          - Dynamically 
            * Running program makes explicit system calls to find library files and load specific functions
      Java:
        - JVM automatically loads and links classes when a program uses them
        - Class loader does a lot of work
          * may load across internet
          * Thoroughly checks loaded code to make sure it complies with JVM requirements
      Delayed Linking Advanteges
        - Multiple programs can share a copy of library functions: one copy on disk and in memory
        - Library functions can be updated independently of programs: all programs use repaired library code next time they run
        - Can avoid loading code that is never used
      Profiling:
        - The classical sequence runs twice
        - Fist run collects statistics: parts frequently executed, for example
        - Second compilation uses this information to help generate better code
      Dynamic compilation
        Some compiling takes place after the program starts running
        Variations
          Compile each function only when called
          Start by interpreting, compile only those pieces that are called frequently
          Compiler roughly at first, then spend more time on frequently executed pieces (i.e. optimize)
        JIT compilation


Mon, Sep 26
  Binding
    - Associating two things, especially associating some property with an identifier from the program
    - Can be done at multiple time
      * Language definition time (creaing a language)
        - Meaning of keywords like void, for, while ect (and datatypes in java)
      * Language implementation (Writing a compiler for the system in question)
        - Range of values of type int in C
        - Implementation limitations: Max identifier length, max array dimensions, ect
      * Compile time
        - Types of variables in statically typed languages
        - Declaration that goes with the given use of a variable
      * Link time
        - When separately-compiled program parts are combined into one executable
        - Object code for external function names
      * Load time
        - Memory locations
      * Runtime
        - Values, types of variables
        - Declaration that goes with a variable
        - Also called late or dynamic binding

    Late vs Early binding
      Late
        * more flexible
      Early
        * faster and more secure (less to do, less to go wrong)
  Debuggers
    * Examine a snapsopt, such as a core dump
    * Examine a running program on the fly
      - Stepping, breakpointing, modifying variables
    * Modify currently running program
    * Advanced debugging features require an IDE

Wed, Sep 28
  Debugging 
    - Examine a snapshot, such as a core dump
    - Examine a running program on the fly
      * Single stepping, breakpointing, modifying variables
    - Modify currently running program
      * Recompiler, relink, reload parts while program runs
    - Advanced debugging features may require an IDE
  
  Debugging information
    - What is ececuting?
    - What is the traceback of calls leading there
    - What are the values of variables
    - Source-level information from machine-level code
      - Variables and functions by name
      - Code locations by source position
    - Connection between levels can be hard to maintain, for example because of optimization
  
  Runtime Support
    - Additional code the linker includes even if the program does not refer to it explicitly
      * Startup processing: initializing the machine state
      * Exception handling: reacting to exceptions
      * Memory management: Allocating memory, reusing it when the program is finished with it
      * Operating system interface: Communicating between running program and operating system for I/O, etc
    - An important hidden player in language systems

  ML
    - Meta Language
    - One of the more popular functional languages
    - Edinburgh Scotland, 1974, Robin Milner's group
    - Many dialects, we're using Standard ML
    - Case sensitive

  Type system
    - int: Standard int
      * use tilde (~) for unary negation. ~1 is 'negative 1'
      * Still use - for binary subtraction
    - real: Real number
    - bool: Boolean
      * true, false
    - string: Text in double quotes
      * Can use C-style escapes
    - char: Character
      * put # before a 1 character string (#"c")

  Operators
    - Standard operators for integers, using ~ for unary negation and - for binary subtraction
      +, -, *, div, mod
    - Same operators but use / for division
      +, -, *, /, mod
    - Precedence:
      (+,-) < (*,/,div,mod) < (~)
    - String concatination
      ^
      "hello " ^ "world"; => "hello world"
    - Ordering comparisons
      <, <=, >, >= 
      Valid for int, real, string, char
    - Equality testing
      = Test equality (similar to == in C)
      <> not equal (similar to != in C)
      Cannot test equality on floats
    - Boolean operators
      * andalso (similar to and in C)
      * orelse (similar to or in C)
      * not
      {orelse} < {andalso} < {=,<>,<,>,<=,>=} < {+,-,^} < {*,/,div,mod} < {~,not}

Fri, Sep 30
  If statement: similar to C ternary statement
    if 1<2 then #"x" else #"y";
    There is no if/then, just if/then/else
  Functions: you apply a function to an argument in ML by putting the function name next to it, parentheses are optional.
    floor 3.6
    floor(3.6)
    `f a b` is the same as `(f a) b`
    square 2+1 ==> square(2) + 1 ==> 5
    square (2+1) ==> 9
  Assignment
    val x = 1+2*3 ==> "val x = 7 : int"
    val y = if x = 7 then 1.0 else 2.0


Mon, Oct 3
  You can define a new variable with the same name as an old one, even a different type
  However, it doesn't reassign the variable, it creates a totally new variable. 
  Any part of the program using the old variable still does. Anything using the new variable uses the new one

  By typing just an expression, the results get assigned to a variable called 'it'

  Tuple
    - Use parentheses to form tuples
    - Tuples can contain other tuples
    - A tuple is like a record with no filed names
    - To get the i'th element of a tuple x, use #i x

  Type constructor *
    - int * int * bool ==> (int, int, bool)
    - (int * int) * bool ==> ((int, int), bool)

  Lists
    - Like Tuples, but must be homogeneous
    - [1,2,3]  ==> int list
    - [1,2.0,3] ==> Will throw error
    - [[1, 2], [4, 5, 6]] ==> int list list

  Nil
    - Empty list [] is nil
    - val it = [] ==> 'a list
    - Variable beginning in 'a is an unknown type
    - 'a list means list of unknown type
  
  Null test
    - null x ==> tests if x is null
    - You could also do x=[], but null x is preferred

  List constructor
    - int list ==> a list of ints

  List operatrions
    - @ ==> Concatenates a list
      * [1,2,3]@[4,5,6] ==> [1,2,3,4,5,6]
    - :: ==> list builder operator (pronounced cons)
      * 1::[2,3,4] ==> pushes 1 to the beginning of a list
      * Right associative
    - hd 
      * function gets head of list
      * hd [1,2,3] ==> [1]
    - tl
      * gets tail of list (Everything but first element)
      * tl [1,2,3] ==> [2,3]
    - explode
      * Takes string and returns list of characters
    - implode
      * Takes list of characters and returns string

  Functions:
    - defined using the fun keyword
    - fun <function-name> <parameter> = <expression>;
    - fun firstChar s = hd (explode s);
    - All functions only take one parameter. If you need multiple values, you can pass a tuple;

Wed, Oct 5
  - fun quot (a,b) = a div b
  - quot (6,2) ==> int 3
  - val tup = (6,2); quot tup ==> int 3

  Recursive functions!
  - fun fact n = 
    if n = 0 then 1
    else n * fact(n-1);

  - fun listsum x = 
    if null x then 0
    else hd x + listsum(tl x);

  Type constructor precedence (first means higher precedence)
    list (lists)
    * (tuple)
    -> (functions)

  Function explicit types
    fun prod(a,b) = a*b ==> int * int -> int
    fun prod(a,b):real = a*b ==> real * real -> real

Fri, Oct 7
  A type is a set
    * When you declare that a vaviable has a certain type, you are saying that the values the variablle can have are elements of a certain set
    * A type is a set of values
      - plus a low level representation
      - plus a collection of operations that can be applied to those values

  Types
    Primitive vs Constructive
      any type that a program can use but cannot define for itself is a primitive type in the language
      Any type that a program can define for itself using primitive types is a constructed type
      - Some primitives in ML are int, real, char
      - Some constructed in ML are list and *

    Primitive Types
      - Definition of a language says what primitive types are
      - Languages define the primitive types more strictly than others
        * Some define the primitive types exactly (Java)
        * Others leave some wiggle room -- the primitive types may be different sets in different implementations of the language

    Comparing Integral types
      C:
        char
        unsigned char
        short int
        unsigned short int
        int
        unsigned int
        long int
        unsigned long int
        - No standard sizes, but longer sizes must be bigger than shorter sizes
      Java:
        byte  (1-byte signed)
        char  (2-byte signed)
        short (2-byte signed)
        int   (4-byte signed)
        long  (8-byte signed)

      Scheme
        integer (unbounded)

    Issues
      What sets do the primitive types signify?
        - How much is part of the language specification, how much left up to the implementation?
        - If necessary, how can a program find out? (In C, INT_MAX. In ML, Int.maxInt)
      what operations are supported
        - Detailed definitions: rounding, exceptions, ect

    Constructed Types
      - Additional types defined using the language
      - Today: enumerations, tuples, arrays, strings, lists, unions, subtypes, and function types
      - For each one, there is connection between how sets are defined mathematically, and how types are defined in programming languages

    Making sets by enumeration
      - Many languages support enumerated types
        C:     enum coin {penny, nickel, dime, quarter};
        Ada:   type GENDER is (MALE, FEMAIL);
        Pacal: type primaryColors = (red, green, blue)
        ML:    datatype day = M | Tu | W | Th | F | Sa | Su

      - These types define a new type
      - They also define a collection of named constants of that type

    Representing Enumeration Values
      - A common representation is to treat the values of an enumeration as small integers
      - This may even be exposed to the programmer, as it is in C
      In C:
        enum coin { penny = 1, nickel = 5, dime = 10, quarter = 25  };


Mon, Oct 10
  Operations on Enumeration Values
    ```SML
      fun isWeekend x = (x = Sa orelse x = Su);
    ```
    If the integer nature of the representation is exposed, a language will allow some or all integer operations

  Making sets by Tupling
    * The Cartesian product of two or more sets defines sets of tuples
    Some languages support pure tuples
      fun get1 (x : real * real) = #1 x;
    Many others support record types, which are just tuples with named fields
      ```SML
        type complex = {
          rp:real,
          ip:real
        };
        fun getip (x: complex) = #ip x;
      ```
    Representing Tuple Values
      A common reprsentation is to just place the elements side-by-side in memroy
      There are lots of details
        - In what order
        - With holes to align elements (word boundries, ect) in memory
        - Is any or all of this visible to the programmer?
    Operations on Tuple Values
      - Selection, of course
        C: x.ip
        ML: #ip x
      - Other operations, depending on how much of the implementation is exposed
    Size of vectors
      *insert discrete math symbols here*
    Types Related to Vectors
      - Arrays, strings, and lists
      - Like tuples, but with many variates
      - One example: indexes
        * What are the index values?
        * Is the array size fixed at compile time?
    Index Values
      - Java, C, C++
        * First element of array a is a[0]
        * zero indexed
      - Pacal is more flexible
        * Various index types are possible: inegers, characters, enumerations, subranges
        * Starting index chosen by the programmer
        * Ending index too: Size is fixed at compile time

Fri, Oct 21
  Making types by union
  In C: union element {
          int i;
          float f;
        }

  In ML:  datatype element {
            I of int |
            F of real;
          }
  Representing union values
    You can have 2 representations overlap each other in memrory
    union element {
      int i;
      char *p;
    } u; /*sizeof(u) == max(sizeof(u.i), sizeof(u.p)) */

  Strictly typed unions
    With ML, all you can do with a union is extract the contents
    dataype element = I of int | F of real;
    fun getReal (F x) = x | getReal (I x) = real x;
  Loosely typed unions
    Some languages expose the details of union implementation
    union element {
      int i;
      float f;
    };

    union element e;
    e.i = 100;
    float x = e.f;

  A middle way: Variant records
    Union where specific type is linked to the value of a field
    A variety of languages including Ada and Modula-2 use this

  Making Subtypes
    A subtype is a type that is a subset of another type
    type digit = 0..9; // Pascal
    subtype DIGIT is INTEGER range 0..9; // Ada

  Representing Subtype Values
    Usually we just use the same representation for the subtype as for the supertype

  Operations on Subtype values
    Usually supports all operators on the supertype, and perhaps additional operations not allowed on the supertyp

  Classes
    Classes are a key idea of object oriented programming
    A class can be a type, data and operations on that data, bundled together
    subclass is a subtype: it includes a subset of the objects, but supports a superset of the operations

  Functions
    Most languages have some notion of the type of a function
  Operations on function values
    We need to call functions
    Many languages support nothing beyond function call


Mon, Oct 24
  Classes
    - The key idea of object-oriented programming
    - Class-based object oriented languages, a class can be a type: data and operations on that data, bundled together
    - A subclass is a subtype: it includes a subset of the objects, but supports a superset of the operations

  Type annotations
    Many language require type annotations on variables, functions, ect
    The programmer uses them to supply static type information to the language system
    They are also a form of documentation, and make programs easier for people to read

  Intrinsic Types
    Some languages use naming conventions to declare the types of variables
    These supply static type information to the language system and the human reader
  
  Extreme Type inference
    ML Infers a static type for every expression and for every function
    doesn't require annotations
  
  Type inferencing
    Most languages require some simpple kinds of type inference
    Constants usually have static types
      Java: 10 is type int, 10L is type long
  
  Static Type checking
    Static type checking determines a type for everything before running the program: variables, functions, expressions, everything
    Compile-time error messages when static types are not sonsistent
      Operations: 1+"abc"
      functions: round("abc")
      statements: if "abc" then ...

  Dynamic typing
    Programs are not statically type-checked before being run
    At runtime, the language system checks that operands are of suitable types for operators

  Example: Lisp
    function to add 2 numbers
      (defun f (a b) (+ a b))
      * Doesn't work if a or b is not a number
      * an improper call, like (f nil nil) is not caught at compile time
      * it's caught at runtime -- dynamic typing

  Dynamic Typing (cont)
    Although dynamic typing does not type everything at compile time, it still uses types
    In a way, it uses them even more than static typing
    It needs to have types to check at runtime
    So the language system must store type information with values in memory

  Staic vs Dynamic
    Not black and white
    Static typed languages often use some dynamic typing
      - Subtypes can cause this
      - Everything is typed at compile time, but compile-time type may have sutypes
    Dynamically typed languages often use some static typing
      - Static types can be inferred for parts of Lisp programs, using constant types and declarations
      - Lisp compilers can use static type information to generate better code, eliminating runtime type checks

  Explicit type tests
    - Some languages allow explicit runtime type tests
      Java: instanceof operator
      Modula-3: branch on object type with typecase statement
    - Requires type information to be present at runtime, even when the language is mostly statically typed

  Strong vs Weak Typing
    - Type checking is to prevent the application of operations ot incorrect types of operands
    - In some languages (Java), type checking can be thorough enough to guarantee this, aka *strong typing*
    - In some languages (C), type checking can have holes to avoid a guaruntee. *weak typing*

  Type equivalence
    - When are two types the same?
    - A language might permit a:=b if a and b are the same types
    - Name equivalence: Types are the same if and only if they have the same name
    - Structural equivalence: types are the same if and only if they are buildt from the same primitive types using the same type constructors in the same order
    - Not the only 2 ways to decide equivalence
    - Languages often uses odd variations or combinations

Wed, Oct 26
  Patterns
    ML functions take a single parameter
      fun f n = n*n
    You can specify multiple inputs with a tuple
      fun f (a,b) = a*b;
    Both n and (a,b) are patterns. The n matches and binds to any argument, while (a,b) matches any 2-tuple and binds a and b to its componenets
    
    Underscore as a pattern
      fun f _ = "yes";
      matches anything, but does not bind it to a variable
      Useful when you don't want to pass an argument to a function
    Constants as a pattern
      fun f 0 = "yes";
      run as 'f 0 ==> "yes"'
      This means that f is defined using a pattern that didn't cover all the domain type (int)
    Lists of patterns
      fun f [a,_] = a;
      f [#'g', #'f'] ==> #'g'
    Cons of patterns as a pattern
      You can use a cons of patterns as a pattern
      x::xs matches any non-empty list, and binds x to the head and xs to the tail
    ML patterns so far
      A variable is a pattern that matches anything, and binds to it
      _ is a pattern that matches anything, but doesn't bind anything
      A constant of an equality type is a pattern that matches only that constant
      A tuple of patterns is a pattern that matches any tuple of the right size, whose contents match the sub-patterns
      A list of patterns is a pattern that matches any list of the right size, whose contents match the sub-patterns
      A cons (::) of patterns is a pattern that matches any non-empty list whose head and tail match the sub-patterns
    Multiple patterns for functions
      fun f 0 = "zero" | f 1 = "one";
    Overlapping patterns
      fun f 0 = "zero" | f _ = "non-zero";
      patterns may overlap
      ML uses first match for a given argument
    Pattern matching style
      fun f 0 = "zero" | f _ = "non-zero";
      fun f n = if 0 then "zero" else "non-zero";
      These are the same, but the pattern matching is generally preferred
    Restriction
      You cannot use the same name in a pattern

Fri, Oct 28
  the polyEqual warning
    fun eq (a,b) = if a=b then 1 else 0;
    warning for an equality comparison, when the runtime type cannot be resolved
    OK to ignore: this kind of equality test is inefficient, but can't always be avoided
  Patterns
    val (a,b) = (1,2.3); // a = 1, b = 2.3
    val a::b = [1,2,3,4,5]; // a = 1, b = [2,3,4,5]
  Local Variable definitions
    When you use val at the top level to define a variable, it is visible from that point forward
    There is a way to restrict the scope of definitions: the let expression
    <let-exp) ::= let <definitions> in <expression> end;
    The value of a let expression is the value of the expression in the in part
    Variables defined with val between the let and the in are visible only from the point of declaration up to the end
  Proper indentation for let
    let
      val x = 1
      val y = 2
    in
      x+y
    end
  Moar code examples (let)
    fun halve nil = (nil, nil) 
    |   halve [a] = ([a], nil)
    |   halve (a::b::cs) =
          let
            val (x,y) = halve cs
          in
            (a::x, b::y)
          end;


Wed, Nov 2
  Comments: delimited by * and *

Fri, Nov 4
  Polymorphism
    - Functions with extra flexibility in types are called polymorphic
    - Applies to a wide variety of language features
  Overloading
    An overloaded function or operator is one that has at least two definitions, all of different types
    Many languages have overloaded operators
    Some allow programmer to define new overloaded function names as operators
  Predefind overloaded operators
    ML: val x = 1 + 2;
        val y = 1.0 + 2.0
  Adding to overloaded operators
    Somve languages, like C++, allow additional meanings to be defined for operators
    class complex {
      double rp, ip;
    public:
      complex(double r, double i) {rp = r; ip = i;}
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
    }
  Operator overloading
    C++ lets you overload virtually any operator
    Overloading function names
      - No big deal
  How to eliminate overloading
    Compiler can't actually give 2 functions same name. Instead modify function names
    - int square_i(int x);
    - double square_d(double x);
  

Mon, Nov 7
  Type Coercion
    Coercion is an implicit type conversion, supplied automatically even if the rpgrammer leaves it out
    In Java:
      double x; x = (double) 2  // Explicit
      double x; x = 2;          // Implicit
  Parameter Coercion
    Languages support different coercions in different contexts: assignments, other binary operations, unary operations, parameters
    When a language supports coercion of parameters on a function call, the resulting function (or operator) is polymorphic
  Defining Coercions
    Language definitions often take many pages to define exactly which coercions are performed
    Some languages have very extensive powers of coercion, while some have none
    Some (like Java) lie in the middle
  Coercion and Overloading: Tricky Interactions
    There are potentially tricky interactions between overloadign and coercion
      - Overloading uses the types to choose the definiion
      - Coercion uses the definition to choose a type conversion
  Parametric Polymorphism
    - A function exhibits parametric polymorphism if it has a type that contains one or more type variables
    - A type with type variables is a polytype
    - Found in languages including ML, C++, Ada, and Java
  Implementing Parametric Polymorphism
    - One extreme: many copies
      Create a set of monomorphic implementations, one for each type parameter the compiler sees
    - Other extreme: one copy
      Create one implementation, and use it for al 
  Subtype Polymorphism  
    A function or operator exhibits it subtype polymorphism if one or more of its parameter types have subtypes
    Important source of polymorphism in languages with a rich structure of subtypes
    Especially object-oriented languages
  Definition of Polymorphic
    A function or operator is polymorphic if it has at least two possible types
      - It exhibits ad hoc polymorphism if it has at least two but only finitely many possible types
      - It exhibits universal polymorphism if it has infinitely many possible types

Fri, Nov 11
  Prolog
    Logical Programming language
    Types: Constants
      Integer constants: 123
      Real constants: 1.23
      Atoms: A lowercase letter followed by any number of additional letters
        - Also can include non-alphanumeric characters * . = @ # $
        - Plus a few special atoms []
      Atoms are not variables, but more like a string constant
      Variables
        Any name beginning with uppercase letter or an underscore, followed by additional letters, digits, or underscores
        Those starting with Underscore get special treatment


Mon, Nov 14
  Variables
    Begin only with uppercase letter or underscore
    Most variables begin with uppercase letter
    Those starting with _ get special treatment
    Anything else is an atom
  Compound term
    Atom followed by a parenthesized, comma-separated list of one or more terms
      x(y,z), +(1,2), .(1,[]), parent(adam,seth), x(Y,x(Y,Z))
  Terms
    All Prolog programs and data are built from terms
  Unification
    Pattern matching using prolog terms
    Two terms unify if there is some way of binding their variables that makes them identical
    parent(adam,Child) and parent(Adameth) unify by binding variable Child to atom seth
  Prolog Database
    Prolog language system maintains collection of facts and rules of inference
    Internal database that changes as Prolog language system runs
    Prolog program is just a set of data for this database
    Simplest kind of thing in the database is a *fact*: a term followed by a period
  Consolut predicate
    consult(relations).
    File relations (or relations.pl) contains our parent facts
  Simple Query
    A query asks the language system to prove something
    Some are true, some are false
    Queries can take multiple lines
    Periods denote end of query
  Queries with variables
    parent(herbert,jean).
    parent(P,jean).
    ==> P = herbert.
    When a query with a variable is used, it prints the results
  Multiple solutions
    When multiple solutions are found, it prints the binding
  Conjunctions
    A conjunctive query has a list of query terms separated by commas
    Prolog tries to prove them all
    parent(Parent,kim), parent(Grandparent,Parent)
    ==> Parent = margaret,
    ==> Grandparent = esther ;
    ==> Parent = margaret,
    ==> Grandparent = herbert ;
  Rules
    greatgrandparent(GGP,GGC) :- 
      parent(GGP,GP), 
      parent(GP,P),
      parent(P,GGC).
    A rule says how to prove something. To prove head, prove conditions
