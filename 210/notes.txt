Professor: Michael Wilder
website: `http://www2.cs.uidaho.edu/~mdwilder/cs210/`
Office Hours: MWF 1:30-2:20 JEB 220

Mon, Aug 22
  * Imperitive Langues
    - Ex: C
    - Hallmarks
      * Assignment
      * Iteration
      * Order of execution is critical
  * Functional Langues
    - Ex: ML, Lisp
    - Hallmarks
      * Single-values variables
      * Heavy use of recursion
  * Logic
    - Ex: Prolog
    - Hallmarks
      * Program expressed as rules in formal logic
  * Object Oriented
    - Ex: C++, Java
    - Hallmarks
      * Usually an extension of imperitive programming
      * Constructs to help programmers use 'objects'

Wed, Aug 24
  Strengths and Weaknesses
    Different language groups show to advantage on different kinds of problems
    Decide for yourself at the end of the semster, after experimenting with them
    For now, one comment: don't jump to conclusions based on factorial!

Fri, Aug 26
  About those families
    There are many other language family terms (not exhaustive and sometimes overlapping)
      - Applicative, concurrent, constraint, declarative, definitional, procedural, scripting, single-assignment
    Some *multi-paradigm languages straddle families: JavaScript, OCaml, Python, Ruby
    Others are so unique that assigning them to a family is pointless

  Forth Factorial (Language that cannot be classified into a category)
  ```
  : FACTORIAL
    1 SAP BEGIN ?DUP WHILE TUCK * SWAP 1- REPEAT ;
  ```
    Stack oriented language
    Postscript is similar
    Could be called imperative, but has little in common with most imperative languages

Mon, Aug 29
  Fighting the Language
    - Languages always favor a particular style, but do not force the programmer to follow it
    - It is always possible to write in a style not favored by the language
    - It is not usually a good idea
  Programming Experience Influenced Language Design
    - Corrections to design problems make future dialects, as already noted
    - Programming styles can emerge before there is a language that supports them
      * Programming with objects predated object-oriented languages
      * Automated theorem proving predates logic languages
  Other connections: Computer Architecture
    - Language evolutino drives and is driven by hardware evolution
      * Call stack support - languages with recursion
      * Parallel architectures - parallel languages
      * Internet - Java
  Turing Equivalence
    - Languages have different strengths, but fundamentally they all have the same power
    - All have the same power as various mathematical models of computation
    - Church-turing thesis: This is what 'computability' means

  Defining Program Syntax
    - Syntax: How programs look, their form and structure
      * Syntax is defined using a kind of formal grammar
    - Semantics: What programs do, their behavior and meaning
      * Axiomatic: using axioms to derive meaning of a program
      * Operational: Specifying how the VM interprets your programs
      * Denotational: Mathematical formalism
  Grammar
    - English Grammar:
      <S> ::= <NP><V><NP>
      <NP> ::= <A><N>
      * The grammar is a set of rules that say how to build a tree - A parse tree
      * You put <S> at the root of the tree
      * The grammar's rules say how children can be added at any point in the tree
      * for insttance, the rule <s> ::= <NP> <V> <NP> says you can add nodes <NP>, <V>, and <NP> in that order, as children of <S>
    - Programming language Grammar
      <exp> ::= <exp> + <exp> | <exp> * <exp> | ( <exp> | a | b | c )
      * An expression can be the sum of two expressions, or the product of two expressions, or a parenthesized subexpression
      * Or it can be one of the variables a, b, or c

Wed, Aug 31
  A BNF grammar consists of four parts
    - A set of tokens
    - The set of non-terminal symbolsence of one or more things, each of which a non-terminal or a token
    - The start symbol
    - The set of productions

    The Productions are the tree building rules
    Each one has a left side, the separator ::= and a right side
    - The right hand side can be a sequ

Mon, Sep 12
  Operator Terminology
    - Infix: a + b
    - Prefix: + a b
    - Postfix: a b +
    Unary Operators: Can be either Prefix or Postfix
  <exp> ::= <exp> + <exp> | <exp> * <exp> | (<exp>) | a | b | c

  Operator Precedence
    Applies when the order of evaluation is not completely decided by parentheses
    Each operator has a precedence leve, and thos with higher precedence are performed before those with lower precedence, as if parenthesized
    Most languages put * before + such that `a+b*c = a+(b*c)`

Fri, Sep 16
  Language Systems
    * The Classical Sequence
      - IDEs are wonderful, but...
      - Old-fashioned, un-integrated systems make the steps involved in running a program more clear
      - We will look the classical sequence of steps involved in running a program

      Integrated Development Environment
      Toolchain:
        A series of tools that have inputs/outputs changed together
        Various tools can (theoretically) be swapped out
        Hard to change in IDEs

    Creating
      - The programmer uses an editor to create a text file containing the program
      - A high-level language: Machine independent

    Compiling
      - Compiler translates to assembly language
      - Machine-specific
      - Each line represents either a piece of data, or a single machine-level instruction
      - Programs used to be written directly in assembly language, before Fortran
      - Now used directly only when the compiler does not do what you want, which is rare

    Assembling
      - Assembly language is still not directly executable
        * Text format, readable by people
        * Still has names, not memory addresses
        * Assembler converts each assembly-language instruction into the machine's binary format: its machine language
        * Resulting object file not readable by people

    Linking
      - Object file still not directly executable
        * Missing some parts
        * Still has some names
        * Mostly machine language, but not entirely
      - Linker collects and combines all the different parts
      - Result is the executable file

Fri, Sep 23
  Virtual Machines
    Cross-platform execution
      - vm can be implemented in software on many different platforms 
      - simulating physical machines is harder
    Heightened security
      - Running program is never directly in charge
      - Interpreter can intervene if the program tries to do something it shouldn't
  The Java Virtual Machine
    Java languages systems usually compile to code for a VM, the JVM
    JVM language is sometimes called bytecode
    Bytecode interpeter is part of almost every webbrowser
    When you browse a ge that contains a Java applet, the browser runs the applet by interpreting its bytecode
  Types if intepreters
    Pure interpreter
      Intermediate language = high-level language
    Tokenizing interpreter
      Intermediate language = token stream
    Intermediate-code compiler
      Intermediate language = virtual machine language
    Native-code compiler
      Intermediate language = physical machine language

    Delayed Linking
      Delay linking step
      Code for library functions is not included in the executable file of the calling program
      Windows:
        - Libraries of functions for delayed linking are stored in .dll files: dynamic-link library
        - Many language systems share this format
        Two flavors:
          - Load-time dynamic linking
            * Loader finds .dll files and links the program to functions it needs, just before running
          - Run-time dynamic linking
            * Running program makes explicit system calls to find .dll files and load specific functions
      Unix:
        - Libraries of functions for delayed linnking are stored in .so files: shared object
        - Suffix .so followed by version number
        - Many language systems share this format
        - Two flavors
          - shared libraries: 
            * Loader linnks the program to functions it needs before running
          - Dynamically 
            * Running program makes explicit system calls to find library files and load specific functions
      Java:
        - JVM automatically loads and links classes when a program uses them
        - Class loader does a lot of work
          * may load across internet
          * Thoroughly checks loaded code to make sure it complies with JVM requirements
      Delayed Linking Advanteges
        - Multiple programs can share a copy of library functions: one copy on disk and in memory
        - Library functions can be updated independently of programs: all programs use repaired library code next time they run
        - Can avoid loading code that is never used
      Profiling:
        - The classical sequence runs twice
        - Fist run collects statistics: parts frequently executed, for example
        - Second compilation uses this information to help generate better code
      Dynamic compilation
        Some compiling takes place after the program starts running
        Variations
          Compile each function only when called
          Start by interpreting, compile only those pieces that are called frequently
          Compiler roughly at first, then spend more time on frequently executed pieces (i.e. optimize)
        JIT compilation
